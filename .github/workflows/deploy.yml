name: Deploy DevOps Notes Manager to EC2

on:
  workflow_run:
    workflows: ["devops-notes-manager CI"]
    types:
      - completed
  workflow_dispatch:

jobs:
  deploy:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy via SSM Run Command
        shell: bash
        run: |
          set -euo pipefail

          ENV_B64=$(cat <<ENV | base64 -w 0
          FLASK_ENV=production
          FLASK_APP=app
          FLASK_RUN_HOST=0.0.0.0
          FLASK_RUN_PORT=5000

          SECRET_KEY=${{ secrets.SECRET_KEY }}
          SESSION_COOKIE_SECURE=true
          REMEMBER_COOKIE_SECURE=true
          SESSION_COOKIE_SAMESITE=Lax
          REMEMBER_COOKIE_SAMESITE=Lax
          UPLOAD_MAX_MB=2

          MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}
          MYSQL_USER=${{ secrets.MYSQL_USER }}
          MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}

          DB_HOST=mysql
          DB_PORT=3306
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}

          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          SMTP_SENDER=${{ secrets.SMTP_SENDER }}
          SMTP_USE_TLS=${{ secrets.SMTP_USE_TLS }}
          RESET_TOKEN_MAX_AGE=${{ secrets.RESET_TOKEN_MAX_AGE }}
          ENV
          )

          COMMANDS=$(cat <<'EOF'
          set -e
          APP_DIR="/home/ubuntu/flask-devops-notes"
          if [ ! -d "$APP_DIR/.git" ]; then
            mkdir -p "$APP_DIR"
            git clone https://github.com/${{ github.repository }}.git "$APP_DIR"
          fi
          cd "$APP_DIR"

          echo "Generating .env file on EC2"
          echo "__ENV_B64__" | base64 -d > .env

          echo "Deploying latest version"
          git pull origin main --rebase
          docker compose pull
          docker compose up -d --build

          echo "Running Database Migrations..."
          docker compose exec -T web python scripts/migrate.py

          echo "Health check..."
          for i in {1..10}; do
            if curl -fsS http://localhost/health; then
              echo "Health check passed"
              break
            fi
            echo "Health check failed, retrying (\$i/10)..."
            sleep 3
          done

          # Final check to fail the deploy if still unhealthy
          curl -fsS http://localhost/health
          EOF
          )
          COMMANDS="${COMMANDS/__ENV_B64__/$ENV_B64}"

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy $GITHUB_SHA" \
            --parameters commands="$COMMANDS" \
            --query "Command.CommandId" \
            --output text)

          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ secrets.EC2_INSTANCE_ID }}"

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
            --query "Status" \
            --output text)

          if [ "$STATUS" != "Success" ]; then
            echo "SSM command failed: $STATUS"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          fi

          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
            --query "StandardOutputContent" \
            --output text
